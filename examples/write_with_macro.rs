use ply_rs_bw::{PlyRead, PlyWrite, ToPly, FromPly};

#[derive(Debug, Default, PlyRead, PlyWrite, Clone, PartialEq)]
struct Vertex {
    #[ply(name = "x")] x: f32,
    #[ply(name = "y")] y: f32,
    #[ply(name = "z")] z: f32,
}

#[derive(Debug, Default, PlyRead, PlyWrite, Clone, PartialEq)]
struct Face {
    #[ply(name = "vertex_indices")] indices: Vec<i32>,
}

#[derive(Debug, ToPly, FromPly, PartialEq)]
struct Mesh {
    #[ply(name = "vertex")]
    vertices: Vec<Vertex>,
    #[ply(name = "face")]
    faces: Vec<Face>,
}

fn create_tetrahedron_mesh() -> Mesh {
    let vertices = vec![
        Vertex { x: 1.0, y: 1.0, z: 1.0 },
        Vertex { x: 1.0, y: -1.0, z: -1.0 },
        Vertex { x: -1.0, y: 1.0, z: -1.0 },
        Vertex { x: -1.0, y: -1.0, z: 1.0 },
    ];

    let faces = vec![
        Face { indices: vec![0, 1, 2] },
        Face { indices: vec![0, 3, 1] },
        Face { indices: vec![0, 2, 3] },
        Face { indices: vec![1, 3, 2] },
    ];

    Mesh { vertices, faces }
}

fn main() {
    let mesh = create_tetrahedron_mesh();
    let mut buf = Vec::<u8>::new();
    
    // Use the trait method generated by ToPly
    // Default is ASCII
    let written = mesh.write_ply(&mut buf).unwrap();
    println!("{} bytes written (ASCII)", written);

    let output = String::from_utf8(buf).unwrap();
    println!("Written PLY data (ASCII):\n{}", output);

    // Write binary PLY
    let mut buf_binary = Vec::<u8>::new();
    let written = mesh.write_ply_with_encoding(&mut buf_binary, ply_rs_bw::ply::Encoding::BinaryLittleEndian).unwrap();
    println!("{} bytes written (Binary Little Endian)", written);

    // Read back to verify
    let mut cursor = std::io::Cursor::new(buf_binary);
    let read_mesh = Mesh::read_ply(&mut cursor).unwrap();
    println!("Read back {} vertices and {} faces", read_mesh.vertices.len(), read_mesh.faces.len());
    
    assert_eq!(mesh, read_mesh);
    println!("Verification successful: Read mesh matches written mesh.");
}
